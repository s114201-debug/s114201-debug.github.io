<!DOCTYPE html>
y += vy;


// 碰到地板
if (y >= floor) {
y = floor;
vy = -vy * bounce; // 反彈


// 速度太小就停止動畫
if (Math.abs(vy) < 1) return;
}


cat.style.top = y + "px";
requestAnimationFrame(fall);
}


requestAnimationFrame(fall);
}


document.addEventListener("click", (e) => {
const img = document.createElement("img");
const randomCat = cats[Math.floor(Math.random() * cats.length)];
img.src = randomCat;
img.className = "cat";
img.style.left = e.clientX + "px";
img.style.top = e.clientY + "px";
document.body.appendChild(img);


applyGravity(img); // 加上重力動畫
});("click", (e) => {
const img = document.createElement("img");
const randomCat = cats[Math.floor(Math.random() * cats.length)];
img.src = randomCat;
img.className = "cat";
img.style.left = e.clientX + "px";
img.style.top = e.clientY + "px";
document.body.appendChild(img);
});
// --- 全域陣列：存放所有貓咪物件 ---
let catsOnScreen = [];


function createCatElement(x, y, src) {
const img = document.createElement("img");
img.src = src;
img.className = "cat";
img.style.left = x + "px";
img.style.top = y + "px";


// 物理屬性
return {
el: img,
x: x,
y: y,
vx: (Math.random() - 0.5) * 4, // 左右初速度
vy: 0,
width: 100,
height: 100,
grounded: false
};
}


// --- 貓咪物理更新 ---
function physicsLoop() {
const gravity = 0.4;
const floor = window.innerHeight - 20;


for (let c of catsOnScreen) {
// 加重力
if (!c.grounded) c.vy += gravity;


// 更新位置
c.x += c.vx;
c.y += c.vy;


// --- 地板碰撞 ---
if (c.y + c.height >= floor) {
c.y = floor - c.height;
c.vy *= -0.3; // 彈力
if (Math.abs(c.vy) < 0.5) {
c.vy = 0;
c.grounded = true;
}
}


// --- 與其他貓咪的碰撞 ---
for (let other of catsOnScreen) {
if (other === c) continue;


// AABB 碰撞檢查
if (
c.x < other.x + other.width &&
c.x + c.width > other.x &&
c.y < other.y + other.height &&
c.y + c.height > other.y
) {
// 水平分離
if (c.x < other.x) {
c.x -= 2;
other.x += 2;
} else {
c.x += 2;
other.x -= 2;
}


// 垂直堆疊
if (c.y < other.y) {
c.y = other.y - c.height;
c.vy = 0;
c.grounded = true;
}
}
}


// 更新 DOM
c.el.style.left = c.x + "px";
c.el.style.top = c.y + "px";
}


requestAnimationFrame(physicsLoop);
}


// 啟動物理循環
requestAnimationFrame(physicsLoop);


document.addEventListener("click", (e) => {
const randomCat = cats[Math.floor(Math.random() * cats.length)];
const newCat = createCatElement(e.clientX, e.clientY, randomCat);


document.body.appendChild(newCat.el);
catsOnScreen.push(newCat);
});
</script>


</body>
</html>
